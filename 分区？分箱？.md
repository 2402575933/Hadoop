首先说明一下分区和分箱的区别：<br>

**分区：** ：
<br> 分区指定多个Reduce时，默认的分区partition策略是利用hashPartitioner进行分区，但是这种对于输入数据Key的随机性而言容易发生数据倾斜的情况，导致进程卡死在某一个地方。支持自定义的Partitioner，
继承Partitioner，通过重写getPartition方法进行自定义划分数据到具体的文件中，虽然各种数据都能通过自定义的模式分配到指定的位置，但是仅仅通过文件名不能有什么代表性，代表哪块分区情况。每一个分区派给指定的Reduce进行执行。

**分箱：**<br>
分箱就是多路径输出，上面分区之后指定内容被发送到指定reduce，一个reduce产生一个part-r-xxxx的文件，尽管处理后的内容已经分文件输出，但是根据文件名字并不能直观的找到相应内容，尤其是文件相对较多时。

- 在reduce或者map类中创建MultipleOutputs对象（最好初始化在setup方法中），在cleanup中关闭流。<br>
```java
class TestReducer extends Reducer<Text, Text, Text, Text>{  
  
    //将结果输出到多个文件或多个文件夹  
    private MultipleOutputs mos;  
 
    protected void setup(Context context) throws IOException,InterruptedException {  
        mos = new MultipleOutputs<>(context);  // 初始化mos
     }  
          
      
    protected void cleanup(Context context) throws IOException,InterruptedException {  
        mos.close();  //关闭对象  
    }  
} 
```
- 在map或reduce方法中使用MultipleOutputs对象输出数据，代替context.write();
```java
protected void reduce(Text key, Iterable<Text> values, Context context)  
            throws IOException, InterruptedException {  
        .... // 计算key和value
        //使用MultipleOutputs对象输出数据  
        if(key.toString().equals("file1")){  
            mos.write("file1", key, value);  
        }else if(key.toString().equals("file2")){  
            mos.write("file2", key, value);    
        }
} 
```

在main方法中添加如下代码：

```java
MultipleOutputs.addNamedOutput(job, "bins", TextOutputFormat.class, Text.class, NullWritable.class);
```
